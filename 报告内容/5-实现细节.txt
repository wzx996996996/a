5 实现细节

5.1 环境搭建步骤

环境搭建包括以下步骤：（1）JDK安装：下载并安装OpenJDK 25（或Java 11+版本），配置JAVA_HOME环境变量。在macOS上可通过Homebrew安装，或从Oracle官网下载。验证安装：执行java -version命令查看版本信息。（2）Maven安装：下载Apache Maven 3.9.11，解压后配置MAVEN_HOME环境变量，并将bin目录添加到PATH。验证安装：执行mvn -version命令。（3）项目依赖下载：进入项目目录，执行mvn clean compile命令，Maven会自动下载JavaFX、OkHttp、Gson等依赖库到本地仓库（~/.m2/repository）。（4）DeepSeek API Key配置：访问https://platform.deepseek.com/注册账号并获取API Key，在终端执行export DEEPSEEK_API_KEY="your-api-key"设置环境变量，或在代码中直接配置（不推荐用于生产环境）。（5）运行环境配置：由于JavaFX采用模块化设计，需要设置模块路径。创建运行脚本run-simple.sh，在脚本中设置JAVA_HOME、提取JavaFX模块路径、配置--module-path和--add-modules参数。执行./run-simple.sh即可启动程序。

5.2 关键代码片段

5.2.1 五子棋棋盘绘制与交互（GobangBoard.java核心代码）

```java
// 第42-44行：创建Canvas画布，用于绘制棋盘
canvas = new Canvas(BOARD_SIZE * CELL_SIZE + OFFSET * 2, 
                   BOARD_SIZE * CELL_SIZE + OFFSET * 2);
gc = canvas.getGraphicsContext2D();
canvas.setOnMouseClicked(this::handleMouseClick);

// 第82-100行：绘制棋盘网格和星位
private void drawBoard() {
    gc.setFill(Color.BEIGE);  // 设置背景色
    gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());
    
    gc.setStroke(Color.BLACK);
    gc.setLineWidth(1.5);
    
    // 绘制15×15网格线
    for (int i = 0; i < BOARD_SIZE; i++) {
        double pos = OFFSET + i * CELL_SIZE;
        gc.strokeLine(OFFSET, pos, OFFSET + (BOARD_SIZE - 1) * CELL_SIZE, pos);
        gc.strokeLine(pos, OFFSET, pos, OFFSET + (BOARD_SIZE - 1) * CELL_SIZE);
    }
    
    // 绘制天元和星位（棋盘上的标记点）
    int[] starPositions = {3, 7, 11};
    gc.setFill(Color.BLACK);
    for (int x : starPositions) {
        for (int y : starPositions) {
            double px = OFFSET + x * CELL_SIZE;
            double py = OFFSET + y * CELL_SIZE;
            gc.fillOval(px - 3, py - 3, 6, 6);
        }
    }
    
    // 重绘已下的棋子
    for (int i = 0; i < BOARD_SIZE; i++) {
        for (int j = 0; j < BOARD_SIZE; j++) {
            if (board[i][j] != 0) {
                drawPiece(i, j, board[i][j] == 1);
            }
        }
    }
}

// 第102-120行：处理鼠标点击事件，实现下棋功能
private void handleMouseClick(MouseEvent event) {
    if (gameOver) return;  // 游戏结束后不再响应点击
    
    double x = event.getX();
    double y = event.getY();
    
    // 计算点击位置对应的棋盘坐标
    int col = (int) Math.round((x - OFFSET) / CELL_SIZE);
    int row = (int) Math.round((y - OFFSET) / CELL_SIZE);
    
    if (col >= 0 && col < BOARD_SIZE && row >= 0 && row < BOARD_SIZE) {
        if (board[row][col] == 0) {  // 检查位置是否为空
            board[row][col] = isBlackTurn ? 1 : 2;  // 1=黑棋，2=白棋
            drawBoard();
            
            // 检查是否获胜
            if (checkWin(row, col)) {
                gameOver = true;
                statusLabel.setText("游戏结束！" + (isBlackTurn ? "黑棋" : "白棋") + "获胜！");
            } else {
                isBlackTurn = !isBlackTurn;  // 切换回合
                statusLabel.setText("当前回合: " + (isBlackTurn ? "黑棋" : "白棋"));
            }
        }
    }
}

// 第122-150行：五连珠检测算法
private boolean checkWin(int row, int col) {
    int player = board[row][col];
    int[][] directions = {{0, 1}, {1, 0}, {1, 1}, {1, -1}};  // 横、竖、左斜、右斜
    
    for (int[] dir : directions) {
        int count = 1;  // 包含当前棋子
        
        // 正向检查
        for (int i = 1; i < 5; i++) {
            int newRow = row + dir[0] * i;
            int newCol = col + dir[1] * i;
            if (newRow >= 0 && newRow < BOARD_SIZE && 
                newCol >= 0 && newCol < BOARD_SIZE && 
                board[newRow][newCol] == player) {
                count++;
            } else {
                break;
            }
        }
        
        // 反向检查
        for (int i = 1; i < 5; i++) {
            int newRow = row - dir[0] * i;
            int newCol = col - dir[1] * i;
            if (newRow >= 0 && newRow < BOARD_SIZE && 
                newCol >= 0 && newCol < BOARD_SIZE && 
                board[newRow][newCol] == player) {
                count++;
            } else {
                break;
            }
        }
        
        if (count >= 5) {
            return true;  // 五连珠，获胜
        }
    }
    return false;
}
```

5.2.2 DeepSeek API调用封装（DeepSeekAPI.java核心代码）

```java
// 第14-34行：DeepSeekAPI类初始化和配置
public class DeepSeekAPI {
    private static final String API_URL = "https://api.deepseek.com/v1/chat/completions";
    private String apiKey;
    private OkHttpClient client;
    private Gson gson;
    
    public DeepSeekAPI() {
        // 从环境变量读取API Key
        this.apiKey = System.getenv("DEEPSEEK_API_KEY");
        if (apiKey == null || apiKey.isEmpty()) {
            this.apiKey = "your-api-key-here";
        }
        
        // 配置HTTP客户端，设置超时时间
        this.client = new OkHttpClient.Builder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(60, TimeUnit.SECONDS)
                .build();
        
        this.gson = new Gson();
    }

// 第41-87行：代码生成核心方法
public String generateCode(String prompt) throws IOException {
    // 构建JSON请求体
    JsonObject requestBody = new JsonObject();
    requestBody.addProperty("model", "deepseek-chat");
    requestBody.addProperty("temperature", 0.7);  // 控制生成随机性
    requestBody.addProperty("max_tokens", 1000);  // 最大生成长度
    
    // 构建消息数组
    JsonObject message = new JsonObject();
    message.addProperty("role", "user");
    message.addProperty("content", prompt);
    
    JsonArray messages = new JsonArray();
    messages.add(message);
    requestBody.add("messages", messages);
    
    // 创建HTTP请求
    RequestBody body = RequestBody.create(
            gson.toJson(requestBody),
            MediaType.get("application/json; charset=utf-8")
    );
    
    Request request = new Request.Builder()
            .url(API_URL)
            .post(body)
            .addHeader("Authorization", "Bearer " + apiKey)
            .addHeader("Content-Type", "application/json")
            .build();
    
    // 发送请求并解析响应
    try (Response response = client.newCall(request).execute()) {
        if (!response.isSuccessful()) {
            throw new IOException("API调用失败: " + response.code());
        }
        
        String responseBody = response.body().string();
        JsonObject jsonResponse = gson.fromJson(responseBody, JsonObject.class);
        
        // 提取生成的代码
        if (jsonResponse.has("choices") && jsonResponse.getAsJsonArray("choices").size() > 0) {
            JsonObject choice = jsonResponse.getAsJsonArray("choices").get(0).getAsJsonObject();
            JsonObject messageObj = choice.getAsJsonObject("message");
            return messageObj.get("content").getAsString();
        } else {
            throw new IOException("API响应格式错误");
        }
    }
}
```

5.2.3 AI代码生成功能集成（GobangBoard.java）

```java
// 第231-270行：AI代码生成演示方法
private void demonstrateAICodeGeneration() {
    aiStatusLabel.setText("AI状态: 正在调用DeepSeek API...");
    
    DeepSeekAPI deepSeek = new DeepSeekAPI();
    
    // 确保使用环境变量中的API Key
    String apiKey = System.getenv("DEEPSEEK_API_KEY");
    if (apiKey != null && !apiKey.isEmpty()) {
        deepSeek.setApiKey(apiKey);
    }
    
    // 构建结构化的Prompt
    String prompt = "请生成一个Java方法，用于计算五子棋棋盘上某个位置周围的空格数量（上下左右四个方向）。" +
                   "方法签名：public int countEmptyNeighbors(int[][] board, int row, int col, int boardSize)" +
                   "要求：返回值为该位置周围（上下左右）空格的数量，board为0表示空格，非0表示已有棋子。";
    
    // 在后台线程中异步调用API，避免阻塞UI
    new Thread(() -> {
        try {
            String generatedCode = deepSeek.generateCode(prompt);
            // 使用Platform.runLater()更新UI（必须在JavaFX应用线程中执行）
            javafx.application.Platform.runLater(() -> {
                aiStatusLabel.setText("AI状态: 代码生成成功！查看控制台");
                System.out.println("========== DeepSeek生成的代码 ==========");
                System.out.println(generatedCode);
                System.out.println("========================================");
            });
        } catch (Exception e) {
            e.printStackTrace();
            javafx.application.Platform.runLater(() -> {
                String errorMsg = e.getMessage();
                if (errorMsg.length() > 60) {
                    errorMsg = errorMsg.substring(0, 60) + "...";
                }
                aiStatusLabel.setText("AI状态: 失败 - " + errorMsg);
            });
        }
    }).start();
}
```

以上核心代码总计约280行，符合150-300行的要求。代码包含详细的注释，说明了关键逻辑和设计考虑。

5.3 UI 界面截图与说明

5.3.1 界面布局

程序启动后显示一个750×850像素的窗口，界面采用BorderPane布局，分为三个区域：

（1）顶部区域：显示游戏状态信息。包含两个Label控件：上方显示"当前回合: 黑棋"（statusLabel），字体16px、加粗；下方显示"AI状态: 未使用"（aiStatusLabel），字体14px、灰色文字。该区域背景为白色，居中对齐，上下内边距10px。

（2）中间区域：五子棋棋盘。使用Canvas组件绘制，尺寸为630×630像素（15×15网格，每格40像素，加上60像素边距）。棋盘背景为米色（Color.BEIGE），网格线为黑色，线宽1.5px。在(3,3)、(3,7)、(3,11)、(7,3)、(7,7)、(7,11)、(11,3)、(11,7)、(11,11)位置绘制黑色圆点作为星位标记。棋子绘制为圆形，黑棋为实心黑色，白棋为白色填充加黑色边框，半径16像素。

（3）底部区域：控制按钮区域。背景为浅蓝色（#e3f2fd），带有蓝色边框（#2196f3，宽度2px），上下内边距20px。包含两个按钮：左侧"重新开始"按钮（宽度130px，高度35px），点击后清空棋盘并重置游戏状态；右侧"🤖 使用AI生成代码"按钮（宽度180px，高度35px，字体14px加粗），点击后触发AI代码生成功能，按钮文字包含机器人图标。

5.3.2 交互功能

（1）下棋操作：用户点击棋盘任意位置，程序计算点击坐标对应的网格位置，如果该位置为空，则在该位置绘制当前回合的棋子（黑棋或白棋），并切换回合。如果点击位置已有棋子或超出棋盘范围，则不响应。

（2）胜负判断：每次下棋后，程序自动检测横、竖、左斜、右斜四个方向是否形成五连珠。如果检测到五连珠，游戏结束，顶部状态标签显示获胜方，棋盘不再响应点击。

（3）游戏重置：点击"重新开始"按钮，清空棋盘数组，重置游戏状态，恢复初始显示。

（4）AI代码生成：点击"使用AI生成代码"按钮后，AI状态标签立即更新为"正在调用DeepSeek API..."，按钮保持可点击状态（异步处理）。API调用成功后，状态标签更新为"代码生成成功！查看控制台"，生成的代码在运行程序的终端窗口中显示，包含完整的Java方法代码、注释和使用示例。如果API调用失败，状态标签显示错误信息。

5.3.3 界面特点

界面设计简洁明了，采用传统的五子棋棋盘样式，符合用户习惯。状态信息实时更新，用户操作反馈及时。AI功能集成自然，不影响游戏体验。整体界面美观实用，适合作为AI辅助编程的实验演示平台。

